recursive = TRUE),
source
)
data.analysis <- readRDS("data/intermediate/data analysis.rds")
pattern <- "^[[:digit:]]*$"
data.spectra <- data.analysis |> dplyr::select(grep(pattern, colnames(data.analysis), value = TRUE))
data.svm <- bind_cols(data.spectra, class = data.analysis$class)
task <- TaskClassif$new(
id = "SVM",
backend = data.svm,
target = "class",
positive = "fresco"
)
task$col_roles$stratum <- "class"
res1 <- tune_svm(task, resampling_folds = 5, n_evals = 30, measure_prob = "classif.acc")
View(tune_svm)
data.analysis <- readRDS("data/intermediate/data analysis.rds")
pattern <- "^[[:digit:]]*$"
data.spectra <- data.analysis |> dplyr::select(grep(pattern, colnames(data.analysis), value = TRUE))
data.svm <- bind_cols(data.spectra, class = data.analysis$class)
task <- TaskClassif$new(
id = "SVM",
backend = data.svm,
target = "class",
positive = "fresco"
)
task$col_roles$stratum <- "class"
res1 <- tune_svm(task, resampling.folds = 5, n.evals = 30, measure.prob = "classif.acc")
source("~/Desktop/NIR/code/Functions.R")
data.analysis <- readRDS("data/intermediate/data analysis.rds")
pattern <- "^[[:digit:]]*$"
data.spectra <- data.analysis |> dplyr::select(grep(pattern, colnames(data.analysis), value = TRUE))
data.svm <- bind_cols(data.spectra, class = data.analysis$class)
task <- TaskClassif$new(
id = "SVM",
backend = data.svm,
target = "class",
positive = "fresco"
)
task$col_roles$stratum <- "class"
res1 <- tune_svm(task, resampling.folds = 5, n.evals = 30, measure.prob = "classif.acc")
source("~/Desktop/NIR/code/Functions.R")
data.analysis <- readRDS("data/intermediate/data analysis.rds")
pattern <- "^[[:digit:]]*$"
data.spectra <- data.analysis |> dplyr::select(grep(pattern, colnames(data.analysis), value = TRUE))
data.svm <- bind_cols(data.spectra, class = data.analysis$class)
task <- TaskClassif$new(
id = "SVM",
backend = data.svm,
target = "class",
positive = "fresco"
)
task$col_roles$stratum <- "class"
res1 <- tune_svm(task, resampling.folds = 5, n.evals = 30, measure.prob = "classif.acc")
res1$accuracy
res1$confusion_matrix
res1$best_params
svm.undersample <- undersample(data.svm, "class", "deteriorato")
task <- TaskClassif$new(
id = "SVM",
backend = svm.undersample,
target = "class",
positive = "fresco"
)
task$col_roles$stratum <- "class"
res2 <- tune_svm(task, resampling_folds = 5, n_evals = 50, measure_prob = "classif.acc")
svm.undersample <- undersample(data.svm, "class", "deteriorato")
task <- TaskClassif$new(
id = "SVM",
backend = svm.undersample,
target = "class",
positive = "fresco"
)
task$col_roles$stratum <- "class"
res2 <- tune_svm(task, resampling.folds = 5, n.evals = 30, measure.prob = "classif.acc")
res2$accuracy
res2$confusion_matrix
res2$best_params
tune_svm_robust <- function(task, resampling.folds = 5, n.evals = 50, measure.prob = "classif.auc") {
# 1. Creiamo una Pipeline con Scaling + SVM
# Lo scaling avviene dentro ogni fold della CV per evitare data leakage
learner = as_learner(po("scale") %>>% lrn("classif.svm", type = "C-classification", predict_type = "prob"))
# 2. Definiamo i parametri (notare il prefisso 'classif.svm.' dovuto alla pipeline)
param.space <- ps(
classif.svm.kernel = p_fct(c("radial", "polynomial", "sigmoid")),
classif.svm.cost = p_dbl(lower = 0.1, upper = 10, logscale = TRUE),
classif.svm.gamma = p_dbl(lower = 0.001, upper = 1, logscale = TRUE)
)
# 3. AutoTuner
at = AutoTuner$new(
learner = learner,
resampling = rsmp("cv", folds = resampling.folds),
measure = msr(measure.prob),
search_space = param.space,
terminator = trm("evals", n_evals = n.evals),
tuner = tnr("random_search")
)
# 4. Valutazione RIGOROSA (Nested Cross-Validation)
# Invece di train/predict sullo stesso task, usiamo resample
set.seed(123)
rr = mlr3::resample(task, at, rsmp("cv", folds = 5), store_models = TRUE)
# Estraiamo i risultati medi reali
list(
aggregate_performance = rr$aggregate(msr(measure.prob)),
all_results = rr,
best_params_last_fold = rr$models[[1]]$archive$best() # Esempio di parametri ottimali
)
}
svm.undersample <- undersample(data.svm, "class", "deteriorato")
task <- TaskClassif$new(
id = "SVM",
backend = svm.undersample,
target = "class",
positive = "fresco"
)
task$col_roles$stratum <- "class"
res2 <- tune_svm_robust(task, resampling.folds = 5, n.evals = 30, measure.prob = "classif.acc")
source("~/.active-rstudio-document")
res2 <- tune_svm_robust(task, resampling.folds = 5, n.evals = 30, measure.prob = "classif.acc")
res2
lapply(list.files("code",
pattern = "\\.R$",
ignore.case = TRUE,
full.names = TRUE,
recursive = TRUE),
source
)
# Carico i dati
data.analysis <- readRDS("data/intermediate/data analysis.rds")
# Seleziono solo le colonne numeriche (spettrali)
pattern <- "^[[:digit:]]*$"
data.spectra <- data.analysis |> dplyr::select(grep(pattern, colnames(data.analysis), value = TRUE))
X <- data.spectra
y <- (data.analysis$class)
set.seed(123)
cost.grid  <- 2^(-1:5)
gamma.grid <- 2^(-10:-2)
tune.res <- tune(
svm,
train.x = X,
train.y = y,
kernel = "radial",
ranges = list(cost = cost.grid, gamma = gamma.grid),
tunecontrol = tune.control(cross = 5)
)
# Miglior modello
best.svm <- tune.res$best.model
# Riepilogo tuning
summary(tune.res)
# Predizioni sul dataset completo
svm.pred <- predict(best.svm, X)
# Confusion matrix
conf.mat <- table(Predicted = svm.pred, True = y)
conf.mat
# Accuracy
accuracy <- sum(diag(conf.mat)) / sum(conf.mat)
accuracy
# Parametri ottimali
best.params <- tune.res$best.parameters
best.params
smoothed.spectra <- smoothing(data.spectra)
snv.spectra <- apply(smoothed.spectra, MARGIN = 1, FUN = normalization)
X <- snv.spectra
set.seed(123)
cost.grid  <- 2^(-1:5)
gamma.grid <- 2^(-10:-2)
tune.res <- tune(
svm,
train.x = X,
train.y = y,
kernel = "radial",
ranges = list(cost = cost.grid, gamma = gamma.grid),
tunecontrol = tune.control(cross = 5)
)
smoothed.spectra <- smoothing(data.spectra)
snv.spectra <- t(apply(smoothed.spectra, MARGIN = 1, FUN = normalization))
X <- snv.spectra
set.seed(123)
cost.grid  <- 2^(-1:5)
gamma.grid <- 2^(-10:-2)
tune.res <- tune(
svm,
train.x = X,
train.y = y,
kernel = "radial",
ranges = list(cost = cost.grid, gamma = gamma.grid),
tunecontrol = tune.control(cross = 5)
)
# Miglior modello
best.svm <- tune.res$best.model
# Riepilogo tuning
summary(tune.res)
# Predizioni sul dataset completo
svm.pred <- predict(best.svm, X)
# Confusion matrix
conf.mat <- table(Predicted = svm.pred, True = y)
conf.mat
# Accuracy
accuracy <- sum(diag(conf.mat)) / sum(conf.mat)
accuracy
# Parametri ottimali
best.params <- tune.res$best.parameters
best.params
measures <- list(
msr("classif.acc"),
msr("classif.auc"),
msr("classif.ce"),
msr("classif.sensitivity"),
msr("classif.specificity")
)
lapply(measures, function(x) msr(x))
measures = c("classif.acc", "classif.auc", "classif.ce", "classif.sensitivity", "classif.specificity")
lapply(measures, function(x) msr(x))
a <- lapply(measures, function(x) msr(x))
a
b <- list(
msr("classif.acc"),
msr("classif.auc"),
msr("classif.ce"),
msr("classif.sensitivity"),
msr("classif.specificity")
)
b
tune_svm <- function(task, resampling_folds = 5, n_evals = 30, measure_prob = "classif.auc",
measures = c("classif.acc", "classif.auc", "classif.ce", "classif.sensitivity", "classif.specificity")) {
assert_task(task, task_type = "classif")
assertNumber(resampling_folds, lower = 5)
assertNumber(n_evals, lower = 30)
assertString(measure_prob)
assertSubset(measure_prob, choices = grep("^classif\\..*", measure_prob, value = TRUE))
# Pipeline con Scaling (Fondamentale per SVM e spettroscopia)
po_scale <- po("scale")
po_balance <- po("classbalancing", adjust = "minor", reference = "major", id = "balance")
learner_svm <- lrn("classif.svm", type = "C-classification", predict_type = "prob")
graph <- po_scale %>>% po_balance %>>% learner_svm
glrn <- GraphLearner$new(graph)
# Spazio di iperparametri (aggiornato per la pipeline)
param_space <- ps(
classif.svm.kernel = p_fct(c("radial", "polynomial", "sigmoid")),
classif.svm.cost = p_dbl(lower = 0.1, upper = 10, logscale = TRUE),
classif.svm.gamma = p_dbl(lower = 0.001, upper = 1, logscale = TRUE)
)
# Configurazione AutoTuner
at <- AutoTuner$new(
learner = glrn,
resampling = rsmp("cv", folds = resampling_folds),
measure = msr(measure_prob),
search_space = param_space,
terminator = trm("evals", n_evals = n_evals),
tuner = tnr("random_search")
)
# Nested Cross-Validation
set.seed(123)
outer_resampling <- rsmp("cv", folds = 5)
rr <- mlr3::resample(task, at, outer_resampling, store_models = TRUE)
# Estrazione dei risultati reali (aggregati dai 5 fold esterni)
performance_reale <- rr$aggregate(lapply(measures, function(x) msr(x)))
# Addestramento finale per estrarre i parametri migliori
at$train(task)
best_params = at$archive$best()$x_domain[[1]]
# 8. Output pulito e completo
list(
nested_performance = performance_reale,
resampling_result = rr, # Contiene i risultati di ogni fold
model = at, # Il modello finale addestrato su tutto
best_params = best_params,
confusion_matrix = rr$prediction()$confusion
)
}
data.analysis <- readRDS("data/intermediate/data analysis.rds")
pattern <- "^[[:digit:]]*$"
data.spectra <- data.analysis |> dplyr::select(grep(pattern, colnames(data.analysis), value = TRUE))
data.svm <- bind_cols(data.spectra, class = data.analysis$class)
task <- TaskClassif$new(
id = "SVM",
backend = data.svm,
target = "class",
positive = "fresco"
)
task$col_roles$stratum <- "class"
tune_svm(task, resampling_folds = 5, n_evals = 50, measure_prob = "classif.acc")
source("settings.R")
lapply(list.files("code",
pattern = "\\.R$",
ignore.case = TRUE,
full.names = TRUE,
recursive = TRUE),
source
)
data.analysis <- readRDS("data/intermediate/data analysis.rds")
cor.data <- data.analysis |> dplyr::select(!c(sample, class))
corr_Kvalue <- cor(cor.data)["K value",]
top.cor <- sort(abs(corr_Kvalue), decreasing = TRUE)
top.cor <- head(top.cor, 10)
data.cluster <- data.analysis |> dplyr::select(grep("^[[:digit:]]*$", names(top.cor), value = TRUE), class)
task <- TaskClassif$new(
id = "Classification original data",
backend = data.cluster,
target = "class",
positive = "fresco"
)
task$col_roles$stratum <- "class"
model_lda(task)
model_qda(task)
tune_knn(task)
data.analysis <- readRDS("data/intermediate/data analysis.rds")
data.cluster <- data.analysis |> dplyr::select(grep("^[[:digit:]]*$", colnames(data.analysis), value = TRUE))
colnames(data.cluster) <- paste0("V", colnames(data.cluster))
data.cluster <- bind_cols(data.cluster, class = data.analysis$class)
task <- TaskClassif$new(
id = "Classification original data",
backend = data.cluster,
target = "class",
positive = "fresco"
)
task$col_roles$stratum <- "class"
# Usiamo il filtro AUC direttamente sul task
filter_auc = flt("auc")
filter_auc$calculate(task)
# Estraiamo i punteggi e creiamo una tabella ordinata
df_scores = as.data.frame(filter_auc$scores)
colnames(df_scores) = "Score_AUC_Raw"
# Calcoliamo l'AUC Reale (Punteggio + 0.5)
df_scores$AUC_Real = round(df_scores$Score_AUC_Raw + 0.5, 3)
# Vediamo le migliori 10
print(head(df_scores, 10))
# Salviamo i nomi delle migliori 5 feature per i modelli successivi
top_features <- rownames(df_scores[3,])
data.cluster <- data.cluster |> dplyr::select(top_features, class)
task <- TaskClassif$new(
id = "Classification original data",
backend = data.cluster,
target = "class",
positive = "fresco"
)
task$col_roles$stratum <- "class"
model_lda(task)
# Salviamo i nomi delle migliori 3 feature per i modelli successivi
top_features <- rownames(df_scores[1:3,])
data.cluster <- data.cluster |> dplyr::select(top_features, class)
task <- TaskClassif$new(
id = "Classification original data",
backend = data.cluster,
target = "class",
positive = "fresco"
)
data.analysis <- readRDS("data/intermediate/data analysis.rds")
data.cluster <- data.analysis |> dplyr::select(grep("^[[:digit:]]*$", colnames(data.analysis), value = TRUE))
colnames(data.cluster) <- paste0("V", colnames(data.cluster))
data.cluster <- bind_cols(data.cluster, class = data.analysis$class)
task <- TaskClassif$new(
id = "Classification original data",
backend = data.cluster,
target = "class",
positive = "fresco"
)
task$col_roles$stratum <- "class"
# Usiamo il filtro AUC direttamente sul task
filter_auc = flt("auc")
filter_auc$calculate(task)
# Estraiamo i punteggi e creiamo una tabella ordinata
df_scores = as.data.frame(filter_auc$scores)
colnames(df_scores) = "Score_AUC_Raw"
# Calcoliamo l'AUC Reale (Punteggio + 0.5)
df_scores$AUC_Real = round(df_scores$Score_AUC_Raw + 0.5, 3)
# Vediamo le migliori 10
print(head(df_scores, 10))
# Salviamo i nomi delle migliori 3 feature per i modelli successivi
top_features <- rownames(df_scores[1:3,])
data.cluster <- data.cluster |> dplyr::select(top_features, class)
task <- TaskClassif$new(
id = "Classification original data",
backend = data.cluster,
target = "class",
positive = "fresco"
)
task$col_roles$stratum <- "class"
model_lda(task)
model_qda(task)
tune_knn(task)
data.analysis <- readRDS("data/intermediate/data analysis.rds")
pattern <- "^[[:digit:]]*$"
data.spectra <- data.analysis |> dplyr::select(grep(pattern, colnames(data.analysis), value = TRUE))
data.svm <- bind_cols(data.spectra, class = data.analysis$class)
task <- TaskClassif$new(
id = "SVM",
backend = data.svm,
target = "class",
positive = "fresco"
)
task$col_roles$stratum <- "class"
tune_svm(task, resampling_folds = 5, n_evals = 30, measure_prob = "classif.acc")
data.analysis <- readRDS("data/intermediate/data analysis.rds")
pattern <- "^[[:digit:]]*$"
data.pca <- data.analysis |> dplyr::select(grep(pattern, colnames(data.analysis), value = TRUE))
pca.res <- prcomp(data.pca, center = TRUE, scale. = TRUE)
summary(pca.res)
pca.df <- data.frame(
PC1 = pca.res$x[, 1],
PC2 = pca.res$x[, 2],
class = data.analysis$class
)
p1 <- ggplot(pca.df, aes(x = PC1, y = PC2, colour = class)) +
geom_point(alpha = 0.8, size = 2.5) +
scale_color_manual(values = c("fresco" = "#003366", "deteriorato" = "#9B1B30")) +
labs(
title = "PCA sugli spettri",
x = paste0("PC1 (", round(summary(pca.res)$importance[2, 1] *100, 1), "%)"),
y = paste0("PC2 (", round(summary(pca.res)$importance[2, 2] *100, 1), "%)"),
color = "Freschezza"
) +
theme_minimal() +
theme(
axis.text.x = element_text(size = 10, angle = 45, hjust = 1),
plot.title = element_text(hjust = 0.5, size = 14, face = "bold"),
panel.grid.major = element_line(color = "lightgray", linewidth = 0.5),
panel.grid.minor = element_blank())
p1
loadings <- pca.res$rotation
contrib <- loadings^2
round(contrib[, 1:2],4)
loadings <- pca.res$rotation
contrib <- loadings^2
round(contrib[, 1:2],4)
task <- TaskClassif$new(
id = "Classification on PCA",
backend = pca.df,
target = "class",
positive = "fresco"
)
task$col_roles$stratum <- "class"
model_lda(task)
model_qda(task)
tune_knn(task)
data.analysis <- readRDS("data/intermediate/data analysis.rds")
pattern <- "^[[:digit:]]*$"
data.spectra <- data.analysis |> dplyr::select(grep(pattern, colnames(data.analysis), value = TRUE))
smoothed.spectra <- smoothing(data.spectra)
norm.spectra <- t(apply(smoothed.spectra, MARGIN = 1, FUN = normalization))
pca.res <- prcomp(norm.spectra, center = TRUE, scale. = FALSE)
summary(pca.res)
pca.df <- data.frame(
PC1 = pca.res$x[, 1],
PC2 = pca.res$x[, 2],
PC3 = pca.res$x[, 3],
PC4 = pca.res$x[, 4],
PC5 = pca.res$x[, 5],
PC6 = pca.res$x[, 6],
PC7 = pca.res$x[, 7],
PC8 = pca.res$x[, 8],
class = data.analysis$class
)
loadings <- pca.res$rotation
contrib <- loadings^2
round(contrib[, 1:8], 4)
task <- TaskClassif$new(
id = "Classification on PCA",
backend = pca.df,
target = "class",
positive = "fresco"
)
model_lda(task)
model_qda(task)
tune_knn(task)
tune_knn(task, resampling_folds = 3)
source("~/Desktop/NIR/code/models.R")
tune_knn(task, resampling_folds = 3)
data.analysis <- readRDS("data/intermediate/data analysis.rds")
pattern <- "^[[:digit:]]*$"
data.spectra <- data.analysis |> dplyr::select(grep(pattern, colnames(data.analysis), value = TRUE))
smoothed.spectra <- smoothing(data.spectra)
norm.spectra <- t(apply(smoothed.spectra, MARGIN = 1, FUN = normalization))
pca.res <- prcomp(norm.spectra, center = TRUE, scale. = FALSE)
summary(pca.res)
pca.df <- data.frame(
PC1 = pca.res$x[, 1],
PC2 = pca.res$x[, 2],
PC3 = pca.res$x[, 3],
PC4 = pca.res$x[, 4],
PC5 = pca.res$x[, 5],
PC6 = pca.res$x[, 6],
class = data.analysis$class
)
p1 <- ggplot(pca.df, aes(x = PC1, y = PC2, colour = class)) +
geom_point(alpha = 0.8, size = 2.5) +
scale_color_manual(values = c("fresco" = "#003366", "deteriorato" = "#9B1B30")) +
labs(
title = "PCA sugli spettri",
x = paste0("PC1 (", round(summary(pca.res)$importance[2, 1] *100, 1), "%)"),
y = paste0("PC2 (", round(summary(pca.res)$importance[2, 2] *100, 1), "%)"),
color = "Freschezza"
) +
theme_minimal() +
theme(
axis.text.x = element_text(size = 10, angle = 45, hjust = 1),
plot.title = element_text(hjust = 0.5, size = 14, face = "bold"),
panel.grid.major = element_line(color = "lightgray", linewidth = 0.5),
panel.grid.minor = element_blank())
p1
loadings <- pca.res$rotation
contrib <- loadings^2
round(contrib[, 1:6], 4)
task <- TaskClassif$new(
id = "Classification on PCA",
backend = pca.df,
target = "class",
positive = "fresco"
)
model_lda(task)
model_qda(task)
tune_knn(task, resampling_folds = 3)
tune_knn(task, resampling_folds = 3, measure_prob = "classif.acc")
