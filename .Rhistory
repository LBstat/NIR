predict_type = "prob"
)
search_space <- ps(
k = p_int(3, 10)
)
at_knn <- AutoTuner$new(
learner = knn,
resampling = rsmp("cv", folds = 5),
measure = msr("classif.auc"),
search_space = search_space,
tuner = tnr("random_search"),
terminator = trm("evals", n_evals = 30)
)
resampling_outer <- rsmp("cv", folds = 10)
resampling_outer$instantiate(task)
# kNN tuned
rr_knn <- resample(task, at_knn, resampling_outer, store_models = TRUE)
# LDA e QDA
rr_lda <- resample(task, lda, resampling_outer, store_models = TRUE)
rr_qda <- resample(task, qda, resampling_outer, store_models = TRUE)
measures <- list(
msr("classif.acc"),
msr("classif.auc"),
msr("classif.ce"),
msr("classif.sensitivity"),
msr("classif.specificity")
)
# kNN
rr_knn$aggregate(measures)
# LDA
rr_lda$aggregate(measures)
# QDA
rr_qda$aggregate(measures)
rr_knn$score()
rr_lda$score()
rr_qda$score()
data.spectra <- readRDS("data/intermediate/data analysis.rds")
install.packages("signal")
library(signal)
# Parameters for Savitzky-Golay
window_size <- 11  # Must be odd, e.g., 5, 7, 11
poly_order <- 2    # Polynomial order (usually 2 or 3)
# Function to smooth a single spectrum
smooth_spectrum <- function(spectrum, window, poly) {
sg_filter <- sgolay(p = poly, n = window)
smoothed <- filter(sg_filter, spectrum)
return(smoothed)
}
data.analysis <- readRDS("data/intermediate/data analysis.rds")
pattern <- "^[[:digit:]]*$"
data.spectra <- data.analysis |> dplyr::select(grep(pattern, colnames(data.analysis), value = TRUE))
library(signal)
# Parameters for Savitzky-Golay
window_size <- 11  # Must be odd, e.g., 5, 7, 11
poly_order <- 2    # Polynomial order (usually 2 or 3)
# Function to smooth a single spectrum
smooth_spectrum <- function(spectrum, window, poly) {
sg_filter <- sgolay(p = poly, n = window)
smoothed <- filter(sg_filter, spectrum)
return(smoothed)
}
# Apply smoothing to all spectra
smoothed_spectra <- t(apply(data.spectra, 1, smooth_spectrum, window = window_size, poly = poly_order))
# smoothed_spectra now contains the smoothed data
# You can plot to compare raw vs smoothed
plot(data.spectra[1,], type = 'l', col = 'red', lwd = 1.5, ylab = 'Absorbance', xlab = 'Wavelength', main = 'Raw vs Smoothed')
# smoothed_spectra now contains the smoothed data
# You can plot to compare raw vs smoothed
plot(data.spectra[1,], col = 'red', lwd = 1.5, ylab = 'Absorbance', xlab = 'Wavelength', main = 'Raw vs Smoothed')
data.spectra
# smoothed_spectra now contains the smoothed data
# You can plot to compare raw vs smoothed
plot(as.matrix(data.spectra[1 ,]), type = 'l', col = 'red', lwd = 1.5, ylab = 'Absorbance', xlab = 'Wavelength', main = 'Raw vs Smoothed')
lines(smoothed_spectra[1,], col = 'blue', lwd = 2)
legend("topright", legend=c("Raw","Smoothed"), col=c("red","blue"), lwd=2)
# smoothed_spectra now contains the smoothed data
# You can plot to compare raw vs smoothed
plot(as.numeric(data.spectra[1 ,]), type = 'l', col = 'red', lwd = 1.5, ylab = 'Absorbance', xlab = 'Wavelength', main = 'Raw vs Smoothed')
lines(smoothed_spectra[1, ], col = 'blue', lwd = 2)
legend("topright", legend=c("Raw","Smoothed"), col=c("red","blue"), lwd=2)
# smoothed_spectra now contains the smoothed data
# You can plot to compare raw vs smoothed
plot(as.numeric(data.spectra[1 ,]), type = 'l', col = 'red', lwd = 1.5, ylab = 'Absorbance', xlab = 'Wavelength', main = 'Raw vs Smoothed')
lines(smoothed_spectra[1, ], col = 'blue', lwd = 2)
legend("topleft", legend=c("Raw","Smoothed"), col=c("red","blue"), lwd=2)
# Parameters for Savitzky-Golay
window_size <- 11  # Must be odd, e.g., 5, 7, 11
poly_order <- 3    # Polynomial order (usually 2 or 3)
# Function to smooth a single spectrum
smooth_spectrum <- function(spectrum, window, poly) {
sg_filter <- sgolay(p = poly, n = window)
smoothed <- filter(sg_filter, spectrum)
return(smoothed)
}
# Apply smoothing to all spectra
smoothed_spectra <- t(apply(data.spectra, 1, smooth_spectrum, window = window_size, poly = poly_order))
# smoothed_spectra now contains the smoothed data
# You can plot to compare raw vs smoothed
plot(as.numeric(data.spectra[1 ,]), type = 'l', col = 'red', lwd = 1.5, ylab = 'Absorbance', xlab = 'Wavelength', main = 'Raw vs Smoothed')
lines(smoothed_spectra[1, ], col = 'blue', lwd = 2)
# Parameters for Savitzky-Golay
window_size <- 13  # Must be odd, e.g., 5, 7, 11
poly_order <- 5    # Polynomial order (usually 2 or 3)
# Function to smooth a single spectrum
smooth_spectrum <- function(spectrum, window, poly) {
sg_filter <- sgolay(p = poly, n = window)
smoothed <- filter(sg_filter, spectrum)
return(smoothed)
}
# Apply smoothing to all spectra
smoothed_spectra <- t(apply(data.spectra, 1, smooth_spectrum, window = window_size, poly = poly_order))
# smoothed_spectra now contains the smoothed data
# You can plot to compare raw vs smoothed
plot(as.numeric(data.spectra[1 ,]), type = 'l', col = 'red', lwd = 1.5, ylab = 'Absorbance', xlab = 'Wavelength', main = 'Raw vs Smoothed')
lines(smoothed_spectra[1, ], col = 'blue', lwd = 2)
# Parameters for Savitzky-Golay
window_size <- 5  # Must be odd, e.g., 5, 7, 11
poly_order <- 5    # Polynomial order (usually 2 or 3)
# Function to smooth a single spectrum
smooth_spectrum <- function(spectrum, window, poly) {
sg_filter <- sgolay(p = poly, n = window)
smoothed <- filter(sg_filter, spectrum)
return(smoothed)
}
# Apply smoothing to all spectra
smoothed_spectra <- t(apply(data.spectra, 1, smooth_spectrum, window = window_size, poly = poly_order))
# smoothed_spectra now contains the smoothed data
# You can plot to compare raw vs smoothed
plot(as.numeric(data.spectra[1 ,]), type = 'l', col = 'red', lwd = 1.5, ylab = 'Absorbance', xlab = 'Wavelength', main = 'Raw vs Smoothed')
lines(smoothed_spectra[1, ], col = 'blue', lwd = 2)
# Parameters for Savitzky-Golay
window_size <- 7  # Must be odd, e.g., 5, 7, 11
poly_order <- 5    # Polynomial order (usually 2 or 3)
# Function to smooth a single spectrum
smooth_spectrum <- function(spectrum, window, poly) {
sg_filter <- sgolay(p = poly, n = window)
smoothed <- filter(sg_filter, spectrum)
return(smoothed)
}
# Apply smoothing to all spectra
smoothed_spectra <- t(apply(data.spectra, 1, smooth_spectrum, window = window_size, poly = poly_order))
# smoothed_spectra now contains the smoothed data
# You can plot to compare raw vs smoothed
plot(as.numeric(data.spectra[1 ,]), type = 'l', col = 'red', lwd = 1.5, ylab = 'Absorbance', xlab = 'Wavelength', main = 'Raw vs Smoothed')
lines(smoothed_spectra[1, ], col = 'blue', lwd = 2)
# Parameters for Savitzky-Golay
window_size <- 7  # Must be odd, e.g., 5, 7, 11
poly_order <- 2    # Polynomial order (usually 2 or 3)
# Function to smooth a single spectrum
smooth_spectrum <- function(spectrum, window, poly) {
sg_filter <- sgolay(p = poly, n = window)
smoothed <- filter(sg_filter, spectrum)
return(smoothed)
}
# Apply smoothing to all spectra
smoothed_spectra <- t(apply(data.spectra, 1, smooth_spectrum, window = window_size, poly = poly_order))
# smoothed_spectra now contains the smoothed data
# You can plot to compare raw vs smoothed
plot(as.numeric(data.spectra[1 ,]), type = 'l', col = 'red', lwd = 1.5, ylab = 'Absorbance', xlab = 'Wavelength', main = 'Raw vs Smoothed')
lines(smoothed_spectra[1, ], col = 'blue', lwd = 2)
# Parameters for Savitzky-Golay
window_size <- 17  # Must be odd, e.g., 5, 7, 11
poly_order <- 2    # Polynomial order (usually 2 or 3)
# Function to smooth a single spectrum
smooth_spectrum <- function(spectrum, window, poly) {
sg_filter <- sgolay(p = poly, n = window)
smoothed <- filter(sg_filter, spectrum)
return(smoothed)
}
# Apply smoothing to all spectra
smoothed_spectra <- t(apply(data.spectra, 1, smooth_spectrum, window = window_size, poly = poly_order))
# smoothed_spectra now contains the smoothed data
# You can plot to compare raw vs smoothed
plot(as.numeric(data.spectra[1 ,]), type = 'l', col = 'red', lwd = 1.5, ylab = 'Absorbance', xlab = 'Wavelength', main = 'Raw vs Smoothed')
lines(smoothed_spectra[1, ], col = 'blue', lwd = 2)
legend("topleft", legend=c("Raw","Smoothed"), col=c("red","blue"), lwd=2)
# Parameters for Savitzky-Golay
window_size <- 17  # Must be odd, e.g., 5, 7, 11
poly_order <- 3    # Polynomial order (usually 2 or 3)
# Function to smooth a single spectrum
smooth_spectrum <- function(spectrum, window, poly) {
sg_filter <- sgolay(p = poly, n = window)
smoothed <- filter(sg_filter, spectrum)
return(smoothed)
}
# Apply smoothing to all spectra
smoothed_spectra <- t(apply(data.spectra, 1, smooth_spectrum, window = window_size, poly = poly_order))
# smoothed_spectra now contains the smoothed data
# You can plot to compare raw vs smoothed
plot(as.numeric(data.spectra[1 ,]), type = 'l', col = 'red', lwd = 1.5, ylab = 'Absorbance', xlab = 'Wavelength', main = 'Raw vs Smoothed')
lines(smoothed_spectra[1, ], col = 'blue', lwd = 2)
pca.res <- prcomp(data.spectra, center = TRUE, scale. = TRUE)
summary(pca.res)
pca.df <- data.frame(
PC1 = pca.res$x[, 1],
PC2 = pca.res$x[, 2],
class = as.factor(data.analysis$class)
)
p1 <- ggplot(pca.df, aes(x = PC1, y = PC2, colour = class)) +
geom_point(alpha = 0.8, size = 2.5) +
scale_color_manual(values = c("fresco" = "#003366", "deteriorato" = "#9B1B30")) +
labs(
title = "PCA sugli spettri",
x = paste0("PC1 (", round(summary(pca.res)$importance[2, 1] *100, 1), "%)"),
y = paste0("PC2 (", round(summary(pca.res)$importance[2, 2] *100, 1), "%)"),
color = "Freschezza"
) +
theme_minimal() +
theme(
axis.text.x = element_text(size = 10, angle = 45, hjust = 1),
plot.title = element_text(hjust = 0.5, size = 14, face = "bold"),
panel.grid.major = element_line(color = "lightgray", linewidth = 0.5),
panel.grid.minor = element_blank())
p1
pca.res.smooth <- prcomp(smoothed_spectra, center = TRUE, scale. = TRUE)
summary(pca.res.smooth)
pca.df.smooth <- data.frame(
PC1 = pca.res.smooth$x[, 1],
PC2 = pca.res.smooth$x[, 2],
class = as.factor(data.analysis$class)
)
p2 <- ggplot(pca.df.smooth, aes(x = PC1, y = PC2, colour = class)) +
geom_point(alpha = 0.8, size = 2.5) +
scale_color_manual(values = c("fresco" = "#003366", "deteriorato" = "#9B1B30")) +
labs(
title = "PCA sugli spettri",
x = paste0("PC1 (", round(summary(pca.res.smooth)$importance[2, 1] *100, 1), "%)"),
y = paste0("PC2 (", round(summary(pca.res.smooth)$importance[2, 2] *100, 1), "%)"),
color = "Freschezza"
) +
theme_minimal() +
theme(
axis.text.x = element_text(size = 10, angle = 45, hjust = 1),
plot.title = element_text(hjust = 0.5, size = 14, face = "bold"),
panel.grid.major = element_line(color = "lightgray", linewidth = 0.5),
panel.grid.minor = element_blank())
p2
install.packages("chemometrics")
data.analysis <- readRDS("data/intermediate/data analysis.rds")
pattern <- "^[[:digit:]]*$"
data.spectra <- data.analysis |> dplyr::select(grep(pattern, colnames(data.analysis), value = TRUE))
library(signal)
library(chemometrics)
# Assume spectra_df: rows = samples, columns = wavelengths
spectra_mat <- as.matrix(spectra_df)  # ensure numeric matrix
# Assume spectra_df: rows = samples, columns = wavelengths
spectra_mat <- as.matrix(data.spectra)  # ensure numeric matrix
# --- Step 1: Smooth spectra using Savitzky-Golay ---
window_size <- 11   # odd number, adjust as needed
poly_order <- 2
smooth_spectrum <- function(spectrum, window, poly) {
sg_filter <- sgolay(p = poly, n = window)
smoothed <- filter(sg_filter, spectrum)
return(smoothed)
}
smoothed_spectra <- t(apply(spectra_mat, 1, smooth_spectrum, window = window_size, poly = poly_order))
# --- Step 2: Compute second derivative (Savitzky-Golay) ---
second_derivative <- function(spectrum, window, poly, m=2) {
sg_filter <- sgolay(p = poly, n = window, m = m)  # m = derivative order
deriv <- filter(sg_filter, spectrum)
return(deriv)
}
deriv_spectra <- t(apply(smoothed_spectra, 1, second_derivative, window = window_size, poly = poly_order))
# --- Step 3: Apply SNV normalization ---
snv_spectra <- t(apply(deriv_spectra, 1, function(x) (x - mean(x))/sd(x)))
# --- Step 4: PCA ---
pca_res <- prcomp(snv_spectra, center = TRUE, scale. = FALSE)
# --- Step 5: Plot PCA scores (PC1 vs PC2) ---
plot(pca_res$x[,1], pca_res$x[,2],
col = sample_labels,  # vector of colors based on freshness stage
pch = 19,
xlab = paste0("PC1 (", round(summary(pca_res)$importance[2,1]*100,1), "%)"),
ylab = paste0("PC2 (", round(summary(pca_res)$importance[2,2]*100,1), "%)"),
main = "PCA of Preprocessed Meat Spectra")
# --- Step 4: PCA ---
pca.res <- prcomp(snv_spectra, center = TRUE, scale. = FALSE)
pca.df <- data.frame(
PC1 = pca.res$x[, 1],
PC2 = pca.res$x[, 2],
class = as.factor(data.analysis$class)
)
p1 <- ggplot(pca.df, aes(x = PC1, y = PC2, colour = class)) +
geom_point(alpha = 0.8, size = 2.5) +
scale_color_manual(values = c("fresco" = "#003366", "deteriorato" = "#9B1B30")) +
labs(
title = "PCA sugli spettri",
x = paste0("PC1 (", round(summary(pca.res)$importance[2, 1] *100, 1), "%)"),
y = paste0("PC2 (", round(summary(pca.res)$importance[2, 2] *100, 1), "%)"),
color = "Freschezza"
) +
theme_minimal() +
theme(
axis.text.x = element_text(size = 10, angle = 45, hjust = 1),
plot.title = element_text(hjust = 0.5, size = 14, face = "bold"),
panel.grid.major = element_line(color = "lightgray", linewidth = 0.5),
panel.grid.minor = element_blank())
p1
loadings <- pca.res$rotation
contrib <- loadings^2
round(contrib[, 1:2],4)
table(pca.df$class)
task <- TaskClassif$new(
id = "Classification on PCA",
backend = pca.df,
target = "class",
positive = "fresco"
)
task
task$col_roles$stratum <- "class"
lda <- lrn("classif.lda", predict_type = "prob")
qda <- lrn("classif.qda", predict_type = "prob")
knn <- lrn(
"classif.kknn",
predict_type = "prob"
)
search_space <- ps(
k = p_int(3, 10)
)
at_knn <- AutoTuner$new(
learner = knn,
resampling = rsmp("cv", folds = 5),
measure = msr("classif.auc"),
search_space = search_space,
tuner = tnr("random_search"),
terminator = trm("evals", n_evals = 30)
)
resampling_outer <- rsmp("cv", folds = 10)
resampling_outer$instantiate(task)
# k-NN tuned
rr_knn <- resample(task, at_knn, resampling_outer, store_models = TRUE)
library(tidyverse)
library(checkmate)
library(patchwork)
library(ggplot2)
library(readxl)
library(mice)
library(mlr3)
library(mlr3learners)
library(mlr3pipelines)
library(caret)
library(kknn)
library(paradox)
library(mlr3tuning)
loadings <- pca.res$rotation
contrib <- loadings^2
round(contrib[, 1:2],4)
table(pca.df$class)
task <- TaskClassif$new(
id = "Classification on PCA",
backend = pca.df,
target = "class",
positive = "fresco"
)
task
task$col_roles$stratum <- "class"
lda <- lrn("classif.lda", predict_type = "prob")
qda <- lrn("classif.qda", predict_type = "prob")
knn <- lrn(
"classif.kknn",
predict_type = "prob"
)
search_space <- ps(
k = p_int(3, 10)
)
at_knn <- AutoTuner$new(
learner = knn,
resampling = rsmp("cv", folds = 5),
measure = msr("classif.auc"),
search_space = search_space,
tuner = tnr("random_search"),
terminator = trm("evals", n_evals = 30)
)
resampling_outer <- rsmp("cv", folds = 10)
resampling_outer$instantiate(task)
# k-NN tuned
rr_knn <- resample(task, at_knn, resampling_outer, store_models = TRUE)
task <- TaskClassif$new(
id = "Classification on PCA",
backend = pca.df,
target = "class",
positive = "fresco"
)
task
task$col_roles$stratum <- "class"
lda <- lrn("classif.lda", predict_type = "prob")
qda <- lrn("classif.qda", predict_type = "prob")
knn <- lrn(
"classif.kknn",
predict_type = "prob"
)
search_space <- ps(
k = p_int(3, 10)
)
at_knn <- AutoTuner$new(
learner = knn,
resampling = rsmp("cv", folds = 5),
measure = msr("classif.auc"),
search_space = search_space,
tuner = tnr("random_search"),
terminator = trm("evals", n_evals = 30)
)
resampling_outer <- rsmp("cv", folds = 10)
resampling_outer$instantiate(task)
# k-NN tuned
rr_knn <- resample(task, at_knn, resampling_outer, store_models = TRUE)
# LDA e QDA
rr_lda <- resample(task, lda, resampling_outer, store_models = TRUE)
rr_qda <- resample(task, qda, resampling_outer, store_models = TRUE)
measures <- list(
msr("classif.acc"),
msr("classif.auc"),
msr("classif.ce"),
msr("classif.sensitivity"),
msr("classif.specificity")
)
# k-NN
rr_knn$aggregate(measures)
# LDA
rr_lda$aggregate(measures)
# QDA
rr_qda$aggregate(measures)
rr_knn$score()
task <- TaskClassif$new(
id = "Classification on PCA",
backend = pca.df,
target = "class",
positive = "fresco"
)
task
task$col_roles$stratum <- "class"
lda <- lrn("classif.lda", predict_type = "prob")
qda <- lrn("classif.qda", predict_type = "prob")
knn <- lrn(
"classif.kknn",
predict_type = "prob"
)
search_space <- ps(
k = p_int(3, 10)
)
at_knn <- AutoTuner$new(
learner = knn,
resampling = rsmp("cv", folds = 5),
measure = msr("classif.auc"),
search_space = search_space,
tuner = tnr("random_search"),
terminator = trm("evals", n_evals = 30)
)
resampling_outer <- rsmp("cv", folds = 10)
resampling_outer$instantiate(task)
# k-NN tuned
rr_knn <- resample(task, at_knn, resampling_outer)
str(pca.df)
data.analysis <- readRDS("data/intermediate/data analysis.rds")
pattern <- "^[[:digit:]]*$"
data.pca <- data.analysis |> dplyr::select(grep(pattern, colnames(data.analysis), value = TRUE))
pca.res <- prcomp(data.pca, center = TRUE, scale. = TRUE)
summary(pca.res)
pca.df <- data.frame(
PC1 = pca.res$x[, 1],
PC2 = pca.res$x[, 2],
class = as.factor(data.analysis$class)
)
p1 <- ggplot(pca.df, aes(x = PC1, y = PC2, colour = class)) +
geom_point(alpha = 0.8, size = 2.5) +
scale_color_manual(values = c("fresco" = "#003366", "deteriorato" = "#9B1B30")) +
labs(
title = "PCA sugli spettri",
x = paste0("PC1 (", round(summary(pca.res)$importance[2, 1] *100, 1), "%)"),
y = paste0("PC2 (", round(summary(pca.res)$importance[2, 2] *100, 1), "%)"),
color = "Freschezza"
) +
theme_minimal() +
theme(
axis.text.x = element_text(size = 10, angle = 45, hjust = 1),
plot.title = element_text(hjust = 0.5, size = 14, face = "bold"),
panel.grid.major = element_line(color = "lightgray", linewidth = 0.5),
panel.grid.minor = element_blank())
p1
ggsave("plot/scatterplotPCA.png", plot = p1, width = 8, height = 6, units = "in")
loadings <- pca.res$rotation
contrib <- loadings^2
round(contrib[, 1:2],4)
table(pca.df$class)
task <- TaskClassif$new(
id = "Classification on PCA",
backend = pca.df,
target = "class",
positive = "fresco"
)
task
task$col_roles$stratum <- "class"
lda <- lrn("classif.lda", predict_type = "prob")
qda <- lrn("classif.qda", predict_type = "prob")
knn <- lrn(
"classif.kknn",
predict_type = "prob"
)
search_space <- ps(
k = p_int(3, 10)
)
at_knn <- AutoTuner$new(
learner = knn,
resampling = rsmp("cv", folds = 5),
measure = msr("classif.auc"),
search_space = search_space,
tuner = tnr("random_search"),
terminator = trm("evals", n_evals = 30)
)
resampling_outer <- rsmp("cv", folds = 10)
resampling_outer$instantiate(task)
# k-NN tuned
rr_knn <- resample(task, at_knn, resampling_outer, store_models = TRUE)
